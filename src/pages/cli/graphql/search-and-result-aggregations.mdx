export const meta = {
  title: `Search and result aggregations`,
  description: `Add authorization rules to your GraphQL schema to control access to your data.`,
};

<MigrationAlert url={"/cli-legacy/graphql-transformer/searchable"}/>

Add the `@searchable` directive to an `@model` type to enable OpenSearch-based data search and result aggregations. This gives you the ability to:
- search for data using advanced filters, such as substring matching, wildcards, regex, `and`/`or`/`not` conditions
- get aggregation values, such as sum, average, min, max, terms
- retrieve total search result count
- sort the search results across one or multiple fields

```graphql
type Student @model @searchable {
  name: String
  dateOfBirth: AWSDate
  email: AWSEmail
  examsCompleted: Int
}
```

> Once the `@searchable` directive is added, all new records added to the model are streamed to OpenSearch. To backfill existing data, see [Backfill OpenSearch index from DynamoDB table](/cli/graphql/troubleshooting#backfill-opensearch-index-from-dynamodb-table).

## Search and filter data

Every model with a `@searchable` directive attached generates a new "search" GraphQL query to search and filter for records. The example above provides you the ability to search for "Student" records using a "searchStudents" query.  

The `filter` parameter allows you to filter for records based on their field values. 

```graphql
query SearchStudentsByEmail {
  searchStudents(filter: { name: { eq: "Rene Brandel" }}) {
    items {
      id
      name
      email
    }
  }
}
```

In the example above, the search result consists of students with the name "Rene Brandel"

### Supported search operations

|Field type|Supported search operations|
|-|-|
|String|ne, eq, match, matchPhrase, matchPhrasePrefix, multiMatch, exists, wildcard, regexp|
|Int|ne, gt, lt, gte, lte, eq, range|
|Float|ne, gt, lt, gte, lte, eq, range|
|Boolean|eq, ne|
|Enum|ne, eq, match, matchPhrase, matchPhrasePrefix, multiMatch, exists, wildcard, regexp|

### Nested search conditions (and, or, not)
Use the filter parameter to pass a nested `and`/`or`/`not` condition. 

```graphql
query MyQuery {
  searchStudents(filter: {
    name: {wildcard: "*Brandel"}
    or: [
      { dateOfBirth: { lt: "2000-01-01" } },
      { email: { exists: true } }
    ]
  }) {
    items {
      id
      name
      email
      dateOfBirth
    }
  }
}
```

By default, every operation in the filter properties is `and`ed. Use the `or` or `not` properties in the search query's `filter` parameter to override this behavior. 

The query above returns a "Student" if:
- their name ends with "Brandel"
- `and`
  - their date of birth is earlier than 2000-01-01
  - `or`
  - their email exists. 

## Sort search results

Use the `sort` parameter to sort your search results by a field in ascending or descending order. The `field` argument accepts any field available on the model. The `direction` accepts either `asc` or `desc`. 

```graphql
query SearchAndSort {
  searchStudents(
    filter: { name: { wildcard: "*Brandel" } },
    sort: { direction: desc, field: name }
  ) {
    items {
      name
      id
    }
  }
}
```

In the example above, the search result is sorted based on their `name` in a `desc`ending order.

### Sort search result over multiple fields

To sort over multiple fields, provide array of sort conditions. When sorting over multiple fields, the sort conditions are applied in the `sort` array's order.

```graphql
query SearchAndSort {
  searchStudents(
    filter: {name: {wildcard: "*Brandel"}},
    sort: [
      {field: name, direction: desc}, # Sort condition #1
      {field: dateOfBirth, direction: asc} # Sort condition #2
    ]  
  ) {
    items {
      id
      name
      dateOfBirth
    }
  }
}
```

In the example above, the search result is first sorted by `name` in a `desc`ending order and then by `dateOfBirth` in an `asc`ending order.

## Paginate over search results

By default, the search result page size is 100. To customize the page size modify the `limit` parameter. Query for the `nextToken` and use it in your subsequent pagination requests:

```
query MyQuery {
  searchTodos(nextToken: "<YOUR_NEXT_TOKEN>") { # Pass in your nextToken in query
    items {
      description
      id
      name
      createdAt
    }
    nextToken # Next token to paginate on
  }
}
```

## Total count of search results

Add the `total` field in your query response to get the total count of search result hits.

```graphql
query MyQuery {
  searchStudents(filter: {name: {wildcard: "*Brandel"}}) {
    items {
      id
    }
    total # Specify to get total counts
  }
}
```

In the example above, the response's `total` field contains the total search result count for "Students" whose name ends with "Brandel". 

## Aggregate values for search result (minimum, maximum, average, sum, terms)

Use the `aggregates` parameter to get aggregate values such as "minimum", "maximum", "average", and "sum" returned in the `aggregateItems` field. 

<BlockSwitcher>
<Block name="Minimum (min)">

Provide the `min` value as the `aggregate` `type` and specify the `aggregateItems` in the response field.

```graphql
query MyQuery {
  searchStudents(
    aggregates: {
      type: min, # Specifies that you want the "min" value
      field: examsCompleted, # Specifies the field for the aggregate value
      name: "minimumExams" # provides a name to reference in the response field 
    } filter: { name: {wildcard: "Rene*"}}) {
    aggregateItems {
      name
      result {
        ... on SearchableAggregateScalarResult {
          value
        }
      }
    }
  }
}
```

In the example above, the response includes the minimum value of "examsCompleted" for all Students whose name starts with "Rene".

```graphql
{
  "data": {
    "searchStudents": {
      "aggregateItems": [{
        "name": "minimumExams",
        "result": {
          "value": 7
        }
      }]
    }
  }
}
```
</Block>

<Block name="Maximum (max)">

Provide the `max` value as the `aggregate` `type` and specify the `aggregateItems` in the response field.

```graphql
query MyQuery {
  searchStudents(
    aggregates: {
      type: max, # Specifies that you want the "max" value
      field: examsCompleted, # Specifies the field for the aggregate value
      name: "maximumExams" # provides a name to reference in the response field 
    } filter: { name: {wildcard: "Rene*"}}) {
    aggregateItems {
      name
      result {
        ... on SearchableAggregateScalarResult {
          value
        }
      }
    }
  }
}
```

In the example above, the response includes the maximum value of "examsCompleted" for all Students whose name starts with "Rene".

```graphql
{
  "data": {
    "searchStudents": {
      "aggregateItems": [{
        "name": "maximumExams",
        "result": {
          "value": 28
        }
      }]
    }
  }
}
```
</Block>

<Block name="Average (avg)">

Provide the `avg` value as the `aggregate` `type` and specify the `aggregateItems` in the response field.

```graphql
query MyQuery {
  searchStudents(
    aggregates: {
      type: avg, # Specifies that you want the "avg" value
      field: examsCompleted, # Specifies the field for the aggregate value
      name: "averageExams" # provides a name to reference in the response field 
    } filter: { name: {wildcard: "Rene*"}}) {
    aggregateItems {
      name
      result {
        ... on SearchableAggregateScalarResult {
          value
        }
      }
    }
  }
}
```

In the example above, the response includes the average value of "examsCompleted" for all Students whose name starts with "Rene".
```graphql
{
  "data": {
    "searchStudents": {
      "aggregateItems": [{
        "name": "averageExams",
        "result": {
          "value": 17.3
        }
      }]
    }
  }
}
```

</Block>

<Block name="Sum (sum)">

Provide the `sum` value as the `aggregate` `type` and specify the `aggregateItems` in the response field.

```graphql
query MyQuery {
  searchStudents(
    aggregates: {
      type: sum, # Specifies that you want the "sum" value
      field: examsCompleted, # Specifies the field for the aggregate value
      name: "examsSum" # provides a name to reference in the response field 
    } filter: { name: {wildcard: "Rene*"}}) {
    aggregateItems {
      name
      result {
        ... on SearchableAggregateScalarResult {
          value
        }
      }
    }
  }
}
```

In the example above, the response includes the sum of all "examsCompleted" values for all Students whose name starts with "Rene".

```graphql
{
  "data": {
    "searchStudents": {
      "aggregateItems": [{
        "name": "examsSum",
        "result": {
          "value": 392
        }
      }]
    }
  }
}
```

</Block>
<Block name="Terms">

Provide the `terms` value as the `aggregate` `type` and specify the `aggregateItems` in the response field.

```graphql
query MyQuery {
  searchTodos(aggregates: {
    field: description,
    type: terms,
    name: "descriptionTerms"
  }) {
    aggregateItems {
      result {
        ... on SearchableAggregateBucketResult {
          __typename
          buckets {
            doc_count
            key
          }
        }
      }
      name
    }
  }
}

```

In the example above, the response includes the terms for the description and their count:

```graphql
{
  "data": {
    "searchTodos": {
      "aggregateItems": [
        {
          "result": {
            "__typename": "SearchableAggregateBucketResult",
            "buckets": [{
                "doc_count": 2,
                "key": "Shopping list"
              }, {
                "doc_count": 1,
                "key": "Me next todo"
              }]
          },
          "name": "descriptionTerms"
        }
      ]
    }
  }
}
```

</Block>
</BlockSwitcher>

## Set up OpenSearch for production environments
By default, Amplify CLI will configure a t2.small instance type. This is great for getting started and prototyping but not recommended to be used in the production environment per the [OpenSearch best practices](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/bp.html). 

To configure the OpenSearch instance type per environment:
1. Run `amplify env add` to create a new environment (e.g. "prod")
2. Edit the `amplify/team-provider-info.json` file and set `ElasticSearchInstanceType` to the instance type that works for your application
```json
{
  "dev": {
    "categories": {
      "api": {
        "<your-api-name>" : {
          "ElasticSearchInstanceType": "t2.small.elasticsearch"
        }
      }
    }
  },
  "prod": {
    "categories": {
      "api": {
        "<your-api-name>" : {
          "ElasticSearchInstanceType": "t2.medium.elasticsearch"
        }
      }
    }
  }
}
```
3. Deploy your changes with `amplify push`

Learn more about Amazon OpenSearch Service instance types [here](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html).

## How it works
The `@searchable` directive streams the data of an @model type to Amazon OpenSearch Service and configures search resolvers to query against OpenSearch.

Type definition of the `@searchable` directive:
```graphql
# Streams data from DynamoDB to OpenSearch and exposes search capabilities.
directive @searchable(queries: SearchableQueryMap) on OBJECT
input SearchableQueryMap { search: String }
```

## Geo Queries
Clients using OpenSearch or Elasticsearch may want to leverage the geo features to search locations or boundaries. OpenSearch and Elasticsearch both offer `geo_point` and `geo_shape` types to help clients perform these types of queries.

Creating a geo query is straightforward. The first step is to [create a custom resolver](https://docs.amplify.aws/cli/graphql/custom-business-logic/#vtl-resolver).

```
amplify add custom
```

```
? How do you want to define this custom resource?
❯ AWS CDK
? Provide a name for your custom resource
❯ MyCustomResolvers
```

Next, install the AppSync dependencies for your custom resource:

```
cd amplify/backend/custom/MyCustomResolvers
npm i @aws-cdk/aws-appsync@~1.124.0
```

Finally, add your custom resolvers into the `cdk-stack.ts` file. You can either add the VTL inline into the `cdk-stack.ts` file or define them externally in another file. Review the [Resolver Mapping Template Programming Guide](https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-programming-guide.html) to learn more about the VTL template.

```ts
import * as cdk from '@aws-cdk/core';
import * as AmplifyHelpers from '@aws-amplify/cli-extensibility-helper';
import * as appsync from '@aws-cdk/aws-appsync';
import { AmplifyDependentResourcesAttributes } from '../../types/amplify-dependent-resources-ref';

export class cdkStack extends cdk.Stack {
  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps, amplifyResourceProps?: AmplifyHelpers.AmplifyResourceProps) {
    super(scope, id, props);
    /* Do not remove - Amplify CLI automatically injects the current deployment environment in this input parameter */
    new cdk.CfnParameter(this, 'env', {
      type: 'String',
      description: 'Current Amplify CLI env name',
    });
    
    // Access other Amplify Resources 
    const retVal:AmplifyDependentResourcesAttributes = AmplifyHelpers.addResourceDependency(this, 
      amplifyResourceProps.category, 
      amplifyResourceProps.resourceName, 
      [{
        category: "api",
        resourceName: "<YOUR-API-NAME>"
      }]
    );

    const resolver = new appsync.CfnResolver(this, "custom-resolver-name", {
      // apiId: retVal.api.new.GraphQLAPIIdOutput,
      // https://github.com/aws-amplify/amplify-cli/issues/9391#event-5843293887
      // If you use Amplify you can access the parameter via Ref since it's a CDK parameter passed from the root stack.
      // Previously the ApiId is the variable Name which is wrong , it should be variable value as below
      apiId: cdk.Fn.ref(retVal.api.replaceWithAPIName.GraphQLAPIIdOutput),
      fieldName: "nameOfQuery", 
      typeName: "Query", // Query | Mutation | Subscription
      // You can create your vtl templates in the root of the custom resolver pkg and import them here instead of writing them inside the class.
      requestMappingTemplate: appsync.MappingTemplate.fromFile(
        path.join(__dirname, '..', 'Query.nameOfQuery.req.vtl')
      ).renderTemplate(),
      responseMappingTemplate: appsync.MappingTemplate.fromFile(
        path.join(__dirname, '..', 'Query.nameOfQuery.res.vtl')
      ).renderTemplate(),
      // If you are using Elasticsearch this will be ElasticSearchDataSource, and if you are using OpenSearch this will be OpenSearchDataSource
      dataSourceName: "OpenSearchDataSource" // DataSource name
    })
  }
}
```

Before you create the templates make sure to create a location field on your model, and properly map the `geo_point` type to the location field. 
OpenSearch and Elasticsearch will not infer the location value as a `geo_point` type, therefore before data is streamed to either service, ensure you map the `geo_point` type.

If you already have existing data stored in OpenSearch or Elasticsearch, use the reindex feature to modify the doc mappings. This can be done by mapping the existing data
to a new doc, removing the old doc, creating a new doc by the same name with the new mappings, and then moving the data from the temporary doc to the new doc. For more information about reindexing, check [here](https://opensearch.org/docs/latest/opensearch/reindex-data/).


```graphql
type Location {
  lat: Float
  lon: Float
}

# Create a query that you can assign to the custom resolver.
type Query {
  nameOfQuery(
    term: String
    total: Int
    nextToken: String
  ): ModelNameConnection
}

```

This should be done before data is streamed or if you have data use reindex.

```ts
PUT /my_locations
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_point"
      }
    }
  }
}
```

Next, create the VTL request and response templates with `geo_point`. 

```vtl
#set( $items = [] )
#foreach( $entry in $context.result.hits.hits )
    #if( !$foreach.hasNext )
        #set( $nextToken = "$entry.sort.get(0)" )
    #end
    $util.qr($items.add($entry.get("_source")))
#end
$util.toJson({
"items": $items,
  "total": $ctx.result.hits.total.value,
  "nextToken": $nextToken
})
```

The following query returns all results within a 200km range of lat 40 and lon -70.
> **Note:** In versions of OpenSearch >= 1.1, you no longer need to use /doc in the index path. Doing so will result in errors when calling the query.

```ts
#set( $indexPath = "/docName/_search" )
#set( $query = $util.defaultIfNull($ctx.args.query, "") )
{
    "version": "2017-02-28",
    "operation": "GET",
    "path": "$indexPath.toLowerCase()",
    "params": {
        "body": {
            "query": {
              "bool": {
                "must": {
                  "match_all": {}
                },
                "filter": {
                  "geo_distance": {
                    "distance": "200km",
                    "pin.location": {
                      "lat": 40,
                      "lon": -70
                    }
                  }
                }
              }
            }
        }
    }
}
```